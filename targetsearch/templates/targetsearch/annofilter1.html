{% extends "base.html" %}
{% load cms_tags %}
{% load targetsearch_extras %}

{% block extra_styles %}
#anno_graph {
    height: 800px;
    border: 1px solid lightgray;
}

.palette-box {
    height: 50px;
    width: 50px;
    border: 2px solid black;
    cursor: pointer;
}

.pw-table-cell {
    padding: 0 0.25em;
}

.pw-table-row-highlight {
    background-color: lightgray;
}
{% endblock extra_styles %}

{% block extra_headers %}
<link rel="stylesheet" href="/static/admin/jquery-ui-1.13.0/jquery-ui.min.css">
<script type="text/javascript" src="/static/admin/jquery-ui-1.13.0/jquery-ui.min.js"></script>
<script type="text/javascript" src="/static/admin/vis-network-9.0.0/standalone/umd/vis-network.min.js"></script>
<script type="text/javascript" src="/static/admin/node_modules/@jaames/iro/dist/iro.min.js"></script>
{% endblock extra_headers %}

{% block base_content %}
<div class="container-fluid">
  <div class="row">{% if message %}<span style="color: red">{{message}}</span>{% endif %}</div>
  <div>
    <h4>Filters</h4>
    <p>If desired, adjust any of the settings below to filter out data rows.
    You'll need to select "Reload Graph" afterward for the graph to reflect your changes.</p>
  </div>
  <div id="filter-row">
    <form>
      <div class="form-row">
        <b title="Limit compound results based on number of target connections." data-toggle="tooltip">Compound-to-target connections <i class="far fa-question-circle"></i> :</b>
      </div>
      <div class="form-row pl-3">
        <div class="col-8">
          <label for="filter_ct_slider">Slider:</label>
          <div id="filter_ct_slider"></div>
        </div>
        <div class="col-2">
          <label for="filter_ct_low">Low:</label>
          <input id="filter_ct_low" class="form-control filter-low filter-range" type="number" step="1" value="1" min="1" max="{{ct_max}}" required="true" autocomplete="off" onchange="filterChange('ct', 'low')">
        </div>
        <div class="col-2">
          <label for="filter_ct_high">High:</label>
          <input id="filter_ct_high" class="form-control filter-high filter-range" type="number" step="1" value="{{ct_max}}" min="1" max="{{ct_max}}" required="true" autocomplete="off" onchange="filterChange('ct', 'high')">
        </div>
      </div>
      <div class="form-row">
        <b title="Limit target results based on number of compound connections." data-toggle="tooltip">Target-to-compound connections <i class="far fa-question-circle"></i> :</b>
      </div>
      <div class="form-row pl-3">
        <div class="col-8">
          <label for="filter_tc_slider">Slider:</label>
          <div id="filter_tc_slider"></div>
        </div>
        <div class="col-2">
          <label for="filter_tc_low">Low:</label>
          <input id="filter_tc_low" class="form-control filter-low filter-range" type="number" step="1" value="1" min="1" max="{{tc_max}}" required="true" autocomplete="off" onchange="filterChange('tc', 'low')">
        </div>
        <div class="col-2">
          <label for="filter_tc_high">high:</label>
          <input id="filter_tc_high" class="form-control filter-high filter-range" type="number" step="1" value="{{tc_max}}" min="1" max="{{tc_max}}" required="true" autocomplete="off" onchange="filterChange('tc', 'high')">
        </div>
      </div>
      <div class="form-row">
        <b title="Limit target results to the selected organisms." data-toggle="tooltip">Organisms <i class="far fa-question-circle"></i> :</b>
      </div>
      {% for o in org_list %}
      <div class="form-check pl-3">
        <input id="org_{{forloop.counter}}" class="form-check-input filter-org" type="checkbox" data-value="{{o}}" checked>
        <label for="org_{{forloop.counter}}" class="form-check-label">{{o}}</label>
      </div>
      {% endfor %}
      <div class="form-row">
        <button type="button" class="btn btn-primary" onclick="applyFilters()">Apply Filters</button>
        <span id="filter_count" class="pl-2 pt-2">0 results have been filtered out.</span>
      </div>
    </form>
  </div>
  <hr>
  <div>
    <h4>Data Table</h4>
    <p>Click on a ChEMBL or Accession ID to highlight that particular node in the graph below.</p>
  </div>
  <div id="table-row">
    <table id="dt">
      <thead>
        <tr>
        {% for c in cols_basic %}<th>{{c}}</th>{% endfor %}
        </tr>
      </thead>

    </table>
  </div>
  <hr>
  <div>
    <h4>Data Graph and Node Info</h4>
    <p>This section displays compound-target connections as a network graph.
    Hover over or select a node to see further information.</p>
  </div>
  {% if org_list|length > 1 %}
  <div id="multi_org_alert" class="alert alert-primary" role="alert">
    This dataset contains targets from multiple organisms. If this is not
    desired, use the filter above to reduce the number of selected organisms.
  </div>
  {% endif %}
  <div id="graph-row" class="row">
    <div class="col-6">
      <div id="anno_graph">Graph not initialized</div>
      <p>
        <button class="btn btn-primary" type="button" onclick="loadGraph()">Reload Graph</button>
        <button class="btn btn-outline-primary" type="button" onclick="resetNodeColors()">Reset Node Colors</button>
        <button class="btn btn-outline-primary" type="button" onclick="openNodeModal()">Show/Hide Nodes</button>
        <button class="btn btn-outline-primary" type="button" onclick="saveAsCsv()">Save as CSV</button>
        <button class="btn btn-outline-primary" type="button" onclick="saveAsJson()">Save as JSON</button>
        <!--button class="btn btn-outline-danger" type="button" onclick="network.stopSimulation()">Freeze Graph</button>
        <button class="btn btn-outline-danger" type="button" onclick="network.destroy()">Unload Graph</button-->
        <span class="d-none">
          <a id="a_dl_csv" href="#" download="cmtools_tsgraph.csv"></a>
          <a id="a_dl_json" href="#" download="cmtools_tsgraph.json"></a>
        </span>
      </p>
      <p>
        Display Gene Ontology Classifications (Reload Graph afterward):
        <ul>
          <li>
            <input id="filter_go_p" type="checkbox" autocomplete="off" checked disabled>
            <label for="filter_go_p">Biological Process</label>
          </li>
          <li>
            <input id="filter_go_c" type="checkbox" autocomplete="off" checked disabled>
            <label for="filter_go_c">Cellular Component</label>
          </li>
          <li>
            <input id="filter_go_f" type="checkbox" autocomplete="off" checked disabled>
            <label for="filter_go_f">Molecular Function</label>
          </li>
        </ul>
      </p>
    </div>
    <div class="col-6">
      <div id="info-panel">
        <div class="alert alert-primary">Select a node on the graph to the left. Detailed information will be displayed here.</div>
      </div>
      <div id="pathway-accordion" class="accordion"></div>
    </div>
  </div>
  <div>ChEMBL database version: {{chembl_version}}</div>
</div>
{% endblock base_content %}

{% block js_content %}
{% include "dataTables.html" %}
{% include "targetsearch/tsg_color_modal.html" %}
{% include "targetsearch/tsg_node_modal.html" %}

{# Django-to-JSON stuff goes here #}
{{ anno_matches | json_script:"anno_matches_json" }}
{{ acc_go_edges | json_script:"acc_go_edges_json" }}
{{ go_nodes | json_script:"go_nodes_json" }}
{{ go_acc_lookup | json_script:"go_acc_lookup_json" }}
{{ acc_reactome_edges | json_script:"acc_reactome_edges_json" }}
{{ reactome_nodes | json_script:"reactome_nodes_json" }}
{{ reactome_acc_lookup | json_script:"reactome_acc_lookup_json" }}
{{ tgt_cmp_lookup | json_script:"tgt_cmp_lookup_json" }}
{{ table_info_dict | json_script:"table_info_json" }}

<script>
  var tbl;

  const anno_matches_all = JSON.parse(document.getElementById("anno_matches_json").text);
  const acc_go_edges = JSON.parse(document.getElementById("acc_go_edges_json").text);
  const go_nodes = JSON.parse(document.getElementById("go_nodes_json").text);
  const go_acc_lookup = JSON.parse(document.getElementById("go_acc_lookup_json").text);
  const acc_reactome_edges = JSON.parse(document.getElementById("acc_reactome_edges_json").text);
  const reactome_nodes = JSON.parse(document.getElementById("reactome_nodes_json").text);
  const reactome_acc_lookup = JSON.parse(document.getElementById("reactome_acc_lookup_json").text);
  const tgt_cmp_lookup = JSON.parse(document.getElementById("tgt_cmp_lookup_json").text);
  const table_info = JSON.parse(document.getElementById("table_info_json").text);

  var anno_matches_filtered = Array.from(anno_matches_all);

  var nodes = new Array();
  var edges = new Array();
  var nodesDS = null;
  var edgesDS = null;
  var nodesView = null;
  var edgesView = null;
  var network = null;

  var graphGroups = {
    compound: {shape: "box", color: "#97C2FC"},
    target: {shape: "ellipse", color: "#FFFF00"},
    P: {shape: "box", color: "#7BE141"},//(123,225,65)
    C: {shape: "box", color: "#6E6EFD"},//(110,110,253)
    F: {shape: "box", color: "#FFA807"}//(255,168,7)
  };

  var selectedAcc = null;
  var selectedGo = null;
  var selectedPwType = null;
  var mostRecentPathway = null;
  var nctIconColors = new Object(); // nctIconColors[pathway_id] -> color
  var sliders = new Object();

  function getCmpDesc(chembl_id) {
    let cmp = cmpNodes.get(chembl_id);
    let desc = chembl_id + "\n----------";

    cmp.forEach((elem, idx) => {
      desc += "\n" + idx + ": " + elem;
    });

    return desc;
  }

  function getTgtDesc(acc_id) {
    let tgt = tgtNodes.get(acc_id);
    let desc = acc_id + "\n----------";

    tgt.forEach((elem, idx) => {
      desc += "\n" + idx + ": " + elem;
    });

    return desc;
  }

  function getGoDesc(go_id) {
    //console.log("getGoDesc called for go_id:", go_id);
    let go_obj = go_nodes[go_id];

    let desc = go_id + "\n----------";
    desc += "\nGene Ontology name: " + go_obj["pref_name"];
    if (go_obj["aspect"] === 'P') {
      desc += "\nAspect: Biological Process";
    } else if (go_obj["aspect"] === 'C') {
      desc += "\nAspect: Cellular Component";
    } else if (go_obj["aspect"] === 'F') {
      desc += "\nAspect: Molecular Function";
    } else {
      desc += "\nAspect: Unknown";
    }
    desc += "\nFull path: " + go_obj["path"];
    desc += "\nClass level: " + go_obj["class_level"];
    if (go_obj["parent_go_id"] != null) {
      desc += "\nParent GO ID: " + go_obj["parent_go_id"];
    } else {
      desc += "\nParent GO ID: None (root term)";
    }

    return desc;
  }

  function getGoDesc2(go_id) {
    let go_obj = go_nodes[go_id];

    let desc = new Array();
    desc.push("Gene Ontology name: " + go_obj["pref_name"]);
    if (go_obj["aspect"] === 'P') {
      desc.push("Aspect: Biological Process");
    } else if (go_obj["aspect"] === 'C') {
      desc.push("Aspect: Cellular Component");
    } else if (go_obj["aspect"] === 'F') {
      desc.push("Aspect: Molecular Function");
    } else {
      desc.push("Aspect: Unknown");
    }
    desc.push("Full path: " + go_obj["path"]);
    desc.push("Class level: " + go_obj["class_level"]);
    if (go_obj["parent_go_id"] != null) {
      desc.push("Parent GO ID: " + go_obj["parent_go_id"]);
    } else {
      desc.push("Parent GO ID: None (root term)");
    }

    return desc;
  }

  function graphNodeFilter(n) {
  /*
    nodes.forEach((elem, idx) => {
      if (elem["id"] === node_id) {
        return elem["show"];
      }
    });
    */
    //console.log(n["id"]);
    //return n["show"];
    let node_id = n["id"];
    //console.log("graphNodeFilter: node_id=", node_id);
    let result = null;
    nodes.forEach((elem, idx) => {
      if (elem["id"] === node_id) {
        //console.log("node_id match");
        result = elem["show"];
        //break;
      } else {
        //console.log("node_id mismatch");
      }
    });
    return result;
  }

  function loadGraph() {
    nodes = new Array();
    edges = new Array();
    // Use these sets to exclude filtered-out nodes
    let cmp_node_set = new Set();
    let tgt_node_set = new Set();
    let go_node_set = new Set();

    // Add compound-target edges
    anno_matches_filtered.forEach((elem, idx) => {
      let from_name = elem["annotation__chembl_id_lookup__chembl_id"];
      let to_name = elem["annotation__component_sequences__accession"];

      let e = new Object();
      e["from"] = from_name;
      e["to"] = to_name;
      edges.push(e);

      cmp_node_set.add(from_name);
      tgt_node_set.add(to_name);
    });

    // Add compound nodes
    cmp_node_set.forEach((idx) => {
      let c = new Object();
      c["id"] = idx;
      c["chembl_id"] = idx;
      c["label"] = idx;
      c["group"] = "compound";
      c["title"] = getCmpDesc(idx);
      c["show"] = true;
      nodes.push(c);
    });

    // Add target nodes
    tgt_node_set.forEach((idx) => {
      let t = new Object();
      t["id"] = idx;
      t["acc_id"] = idx;
      t["label"] = idx;
      t["group"] = "target";
      t["title"] = getTgtDesc(idx);
      t["show"] = true;
      nodes.push(t);
    });

    // Add GO nodes (new)
    for (i in go_nodes) {
      let elem = go_nodes[i];
      let o = new Object();
      o["id"] = elem["go_id"];
      o["go_id"] = elem["go_id"];
      o["label"] = elem["go_id"];
      o["group"] = elem["aspect"];
      o["title"] = getGoDesc(elem["go_id"]);
      o["show"] = {% if search_type == "chembl" %}false{% else %}true{% endif %};
      nodes.push(o);
    }

    // Add GO edges (new)
    // Note: FROM=pathway node, TO=drug target
    for (acc_id in acc_go_edges) {
      if (acc_id != "ALL") {
        acc_go_edges[acc_id].forEach((elem, idx) => {
          let e = new Object();
          e["from"] = elem;
          e["to"] = acc_id;
          edges.push(e);
        });
      }
    }

    // Add Reactome nodes
    for (i in reactome_nodes) {
      let elem = reactome_nodes[i];
      let o = new Object();
      o["id"] = elem["reactome_id"];
      o["reactome_id"] = elem["reactome_id"];
      o["label"] = elem["reactome_id"];
      o["group"] = "reactome";
      o["title"] = elem["event_name"];
      o["show"] = {% if search_type == "chembl" %}false{% else %}true{% endif %};
      nodes.push(o);
    }
    //console.log("nodes: ", nodes);

    // Add Reactome edges
    for (acc_id in acc_reactome_edges) {
      if (acc_id != "ALL") {
        acc_reactome_edges[acc_id].forEach((elem, idx) => {
          let e = new Object();
          e["from"] = elem;
          e["to"] = acc_id;
          edges.push(e);
        });
      }
    }

    nodesDS = new vis.DataSet(nodes);
    edgesDS = new vis.DataSet(edges);

    nodesView = new vis.DataView(nodesDS, {filter: graphNodeFilter});
    edgesView = new vis.DataView(edgesDS);

    var graphContainer = document.getElementById("anno_graph");
    var graphData = {nodes: nodesView, edges: edgesView};
    var graphOpts = {edges: { smooth: false}, groups: graphGroups};
    network = new vis.Network(graphContainer, graphData, graphOpts);

    network.on("selectNode", function (sne) {
      //console.log("selectNode Event:", sne);
      let node_id = sne.nodes[0];
      updateInfoPanel(node_id);
    });
  }

  function updateInfoPanel(node_id) {
    n = nodesDS.get(node_id);

    let header_html = "";
    let info_html = "";
    info_html += n.title.replaceAll("\n", "</br>");
    if (n.group == "compound") {
      header_html = "<h5>Compound Info</h5>"
      let cmt_url = "/targetsearch/detail/"+n.chembl_id;
      let ebi_url = "https://www.ebi.ac.uk/chembl/compound_report_card/"+n.chembl_id+"/";
      info_html += '<p><a class="btn btn-primary" role="button" href="'+cmt_url+'" target="_blank">ChemMine Tools Compound Info</a></p>';
      info_html += '<p><a class="btn btn-primary" role="button" href="'+ebi_url+'" target="_blank">EBI ChEMBL Report Card</a></p>';

      $("#pathway-accordion").html("");
    } else if (n.group == "target") {
      header_html = "<h5>Target Info</h5>"
      let uniprot_url = "https://www.uniprot.org/uniprot/"+n.acc_id;
      info_html += '<p><a class="btn btn-primary" role="button" href="'+uniprot_url+'" target="_blank">Uniprot Info</a></p>';

      selectedAcc = n.id;
      //updateChartAcc(n.id);
      renderPathwayList(getPathwayData(n.id));
    } else if (n.group == "P" || n.group == "C" || n.group == "F") {
      header_html = "<h5>Gene Ontology Term Info</h5>"
      let go_url = "http://amigo.geneontology.org/amigo/term/"+n.go_id;
      info_html += '<p><a class="btn btn-primary" role="button" href="'+go_url+'" target="_blank">AmiGO Page</a></p>';
      info_html += '<p><button type="button" class="btn btn-outline-primary" data-toggle="modal" data-target="#tsgcModal">Node Color Tool</button></p>';

      selectedGo = n.id;
      selectedPwType = "go";
      //$("#pathway-accordion").html("");
    } else if (n.group == "reactome") {
      header_html = "<h5>Reactome Info</h5>";
      let pw_url = "https://reactome.org/PathwayBrowser/#/"+n.id;
      info_html += '<p><a class="btn btn-primary" role="button" href="'+pw_url+'" target="_blank">Reactome Pathway Browser Page</a></p>';
      info_html += '<p><button type="button" class="btn btn-outline-primary" data-toggle="modal" data-target="#tsgcModal">Node Color Tool</button></p>';

      selectedGo = n.id;
      selectedPwType = "reactome";
    } else {
      header_html += '<h5>Unknown node type.</h5>';
      $("#pathway-accordion").html("");
    }
    //document.getElementById("anno_info").innerHTML = info_html;
    $("#info-panel").html(header_html + info_html);
  }

  // Gather pathway data for a given target based on Accession ID
  // Usually called when a target node is selected in the network graph
  function getPathwayData(acc_id) {
    //console.log("getPathwayData: acc_id=", acc_id);

    // Structured list data for all the pathways we want to support
    // label: display text for the overall category
    // list: list of pathway IDs only
    // datasrc: pointer to data object containing detailed info
    let pathway_data = new Object();
    pathway_data["go_p"] = {label: "Gene Ontology - Biological Process", type: "go", list: new Array(), datasrc: go_nodes};
    pathway_data["go_c"] = {label: "Gene Ontology - Cellular Component", type: "go", list: new Array(), datasrc: go_nodes};
    pathway_data["go_f"] = {label: "Gene Ontology - Molecular Function", type: "go", list: new Array(), datasrc: go_nodes};
    pathway_data["reactome"] = {label: "Reactome", type:"reactome",  list: new Array(), datasrc: null};
    //pathway_data["kegg"] = {label: "KEGG (Placeholder)", list: new Array(), datasrc: null};

    // Populate GO info
    acc_go_edges[acc_id].forEach((elem, idx) => {
      let n = go_nodes[elem];
      if (n["aspect"] === "P") {
        pathway_data["go_p"]["list"].push(elem);
      } else if (n["aspect"] === "C") {
        pathway_data["go_c"]["list"].push(elem);
      } else if (n["aspect"] === "F") {
        pathway_data["go_f"]["list"].push(elem);
      } else {
        console.error("getPathwayData: ERROR: unknown GO aspect:", n["aspect"]);
      }
    });

    // Populate Reactome info
    pathway_data["reactome"]["list"] = acc_reactome_edges[acc_id];

    return pathway_data;
  }

  // Update the accordion list to show a target's pathways
  function renderPathwayList(pathway_data) {
    let newPathwayHtml = '<h5>Pathway Info</h5><div class="alert alert-primary">Click on a category to expand its contents.</div>';
    let first_card = " show";
    for (p in pathway_data) {
      let pw_card_id = "pathway-card-"+p;
      let pw_card_title = `${pathway_data[p]["label"]} (${pathway_data[p]["list"].length})`;

      let pw_header_btn = `<button class="btn btn-link flex-grow-1 text-left" type="button" data-toggle="collapse" data-target="#${pw_card_id}-body">${pw_card_title}</button>`;
      let pw_header = `<div class="card-header d-flex mb-0 p-0">${pw_header_btn}</div>`;

      let pw_table_help = '<p>Select the paint brush icon (<i class="fas fa-paint-brush"></i>) to use the Node Color Tool.<br>';
      pw_table_help += 'A pathway with a custom color will have its icon replaced with a colored square (<i class="fas fa-square"></i>).<br>';
      pw_table_help += 'The most recently modified pathway will be highlighted.</p>';

      let pw_table = "";
      if (pathway_data[p]["type"] == "go") {
        pw_table += '<table style="border-collapse: collapse;">';
        pw_table += '<thead><tr>';
        pw_table += '<th class="pw-table-cell"></th>';
        pw_table += '<th class="pw-table-cell">GO ID</th>';
        pw_table += '<th class="pw-table-cell">Description</th>';
        pw_table += '<th class="pw-table-cell">Parent GO ID</th>';
        pw_table += '</tr></thead><tbody>';
        pathway_data[p]["list"].forEach((elem, idx) => {
          pw_table += `<tr class="pw-table-row" data-nodeid="${elem}">`;
          pw_table += `<td class="pw-table-cell"><a href="javascript:openColorTool('${elem}', 'go')"><i class="fas fa-paint-brush nct-icon" data-nodeid="${elem}"></i></a></td>`;
          let go_url = `http://amigo.geneontology.org/amigo/term/${elem}`;
          pw_table += `<td class="pw-table-cell"><a href="${go_url}" target="_blank">${elem}</a></td>`;
          pw_table += `<td class="pw-table-cell">${go_nodes[elem]["pref_name"]}</td>`;
          pw_table += `<td class="pw-table-cell">${go_nodes[elem]["parent_go_id"]}</td>`;
          pw_table += '</tr>';
        });
        pw_table += '</tbody></table>';
      } else if (pathway_data[p]["type"] == "reactome") {
        pw_table += '<table style="border-collapse: collapse;">'
        pw_table += '<thead><tr>';
        pw_table += '<th class="pw-table-cell"></th>';
        pw_table += '<th class="pw-table-cell">Reactome ID</th>';
        pw_table += '<th class="pw-table-cell">Description</th>';
        pw_table += '</tr></thead><tbody>';
        pathway_data[p]["list"].forEach((elem, idx) => {
          pw_table += '<tr class="pw-table-row" data-nodeid="'+elem+'">';
          pw_table += '<td class="pw-table-cell"><a href="javascript:openColorTool(\''+elem+'\', \'reactome\' )"><i class="fas fa-paint-brush nct-icon" data-nodeid="'+elem+'"></i></a></td>';
          pw_table += '<td class="pw-table-cell"><a href="'+reactome_nodes[elem]["url"]+'" target="_blank">'+elem+'</a></td>';
          pw_table += '<td class="pw-table-cell">'+reactome_nodes[elem]["event_name"]+'</td>';
          pw_table += '</tr>';
        });
        pw_table += '</tbody></table>';
      }

      let pw_body = '<div id="'+pw_card_id+'-body" class="collapse'+first_card+'" data-parent="#pathway-accordion"><div class="card-body">'+pw_table_help+pw_table+'</div></div>';
      first_card = "";
      let pw_card = '<div id="'+pw_card_id+'" class="card">'+pw_header+pw_body+'</div>';
      newPathwayHtml += pw_card;
    }
    $("#pathway-accordion").html(newPathwayHtml);

    refreshNCTicons();
    refreshMRPW();
  }

  function openColorTool(pathway_id, pathway_type) {
    selectedGo = pathway_id;
    selectedPwType = pathway_type;
    $("#tsgcModal").modal();
  }

  function openNodeModal() {
    tsgnmRefresh();
    $("#tsgnModal").modal();
  }

  function showTsgcModal(event, elem, chart) {
    /*console.log("showTsgcModal:");
    console.log("  event=", event);
    console.log("  elem=", elem);
    console.log("  chart=", chart);*/

    $("#tsgcModal").modal();
  }

  // Export the graph network data as CSV
  function saveAsCsv() {
    //console.log("saveAsCsv begin");
    let csv_file = "ChEMBL ID\tPreferred Name\tMechanism of Action\tAccession Id\tTarget Description\tOrganism\tPathway Id\tPathway Type\tPathway Description\n";
    let anno_field_output = ["annotation__chembl_id_lookup__chembl_id",
                        "annotation__molecule_dictionary__pref_name",
                        "annotation__drug_mechanism__mechanism_of_action",
                        "annotation__component_sequences__accession",
                        "annotation__component_sequences__description",
                        "annotation__component_sequences__organism"];

    // By using nested for-loops, we output one line for every
    // compound-target-pathway relation
    anno_matches_filtered.forEach((elem) => {
      // Build the annotation part (save separately so we can use it in multiple lines)
      let anno_part = new Array();
      anno_field_output.forEach((field) => {
        anno_part.push(elem[field]);
      });

      let acc_id = elem["annotation__component_sequences__accession"];
      // Build the GO part and print the line
      acc_go_edges[acc_id].forEach((go_id) => {
        let go_part = new Array();
        go_part.push(go_id);
        go_part.push("Gene Ontology");
        go_part.push(go_nodes[go_id]["pref_name"]);

        csv_file += anno_part.join("\t") + "\t" + go_part.join("\t") + "\n";
      });
      // Build the Reactone part and print the line
      acc_reactome_edges[acc_id].forEach((r_id) => {
        let r_part = new Array();
        r_part.push(r_id);
        r_part.push("Reactome");
        r_part.push(reactome_nodes[r_id]["event_name"]);

        csv_file += anno_part.join("\t") + "\t" + r_part.join("\t") + "\n";
      });
    });

    //console.log("csv_file:", csv_file);
    $("#a_dl_csv").attr("href", "data:text/plain;base64,"+btoa(csv_file));
    document.getElementById("a_dl_csv").click();
    //console.log("saveAsCsv end");
    //return csv_file;
  }

  // Export the graph network data as JSON
  function saveAsJson() {
    //console.log("saveAsJson begin");
    let json_file = new Object();
    let cmp_info = new Object();
    let tgt_info = new Object();
    let pw_info = new Object();
    let cmp_to_tgt = new Array();
    let tgt_to_pw = new Array();

    // Populate the JSON file with compound and target data
    anno_matches_filtered.forEach((anno_elem) => {
      let chembl_id = anno_elem["annotation__chembl_id_lookup__chembl_id"];
      let acc_id = anno_elem["annotation__component_sequences__accession"];
      if ( !(chembl_id in cmp_info) ) {
        let ci = new Object();
        ci["chembl_id"] = chembl_id;
        ci["pref_name"] = anno_elem["annotation__molecule_dictionary__pref_name"];
        ci["mechanism_of_action"] = anno_elem["annotation__drug_mechanism__mechanism_of_action"];
        cmp_info[chembl_id] = ci;
      }
      if ( !(acc_id in tgt_info) ) {
        let ti = new Object();
        ti["accession_id"] = acc_id;
        ti["description"] = anno_elem["annotation__component_sequences__description"];
        ti["organism"] = anno_elem["annotation__component_sequences__organism"];
        tgt_info[acc_id] = ti;
      }
      cmp_to_tgt.push({"from": chembl_id, "to": acc_id});
    });

    // Populate the JSON file with pathway data
    // (use tgt_info to only include targets that pass the filter)
    for (acc_id in tgt_info) {
      // Load GO data
      acc_go_edges[acc_id].forEach((go_id) => {
        if ( !(go_id in pw_info) ) {
          let pi = new Object();
          pi["id"] = go_id;
          pi["type"] = "Gene Ontology";
          pi["description"] = go_nodes[go_id]["pref_name"];

          pw_info[go_id] = pi;
        }

        tgt_to_pw.push({"from": acc_id, "to": go_id});
      });

      // Load Reactome data
      acc_reactome_edges[acc_id].forEach((r_id) => {
        if ( !(r_id in pw_info) ) {
          let pi = new Object();
          pi["id"] = r_id;
          pi["type"] = "Reactome";
          pi["description"] = reactome_nodes[r_id]["event_name"];

          pw_info[r_id] = pi;
        }

        tgt_to_pw.push({"from": acc_id, "to": r_id});
      });
    }

    json_file["compound_info"] = cmp_info;
    json_file["target_info"] = tgt_info;
    json_file["pathway_info"] = pw_info;
    json_file["compound_to_target"] = cmp_to_tgt;
    json_file["target_to_pathway"] = tgt_to_pw;

    $("#a_dl_json").attr("href", "data:text/plain;base64,"+btoa(JSON.stringify(json_file)));
    document.getElementById("a_dl_json").click();
    //console.log("saveAsJson end");
    //return json_file;
  }

  function applyFilters() {
    //let exclude_set = new Set();

    let filter_ct_low = parseInt($("#filter_ct_low").prop("value"));
    let filter_ct_high = parseInt($("#filter_ct_high").prop("value"));
    let filter_tc_low = parseInt($("#filter_tc_low").prop("value"));
    let filter_tc_high = parseInt($("#filter_tc_high").prop("value"));

    let exclude_cmp = new Set();
    cmpNodes.forEach((elem, idx) => {
      let e_rel = elem.get("Number of Target Relations");
      if (e_rel < filter_ct_low || e_rel > filter_ct_high) {
        exclude_cmp.add(idx);
      }
    });

    let exclude_tgt = new Set();
    tgtNodes.forEach((elem, idx) => {
      let e_rel = elem.get("Number of Compound Relations");
      if (e_rel < filter_tc_low || e_rel > filter_tc_high) {
        exclude_tgt.add(idx);
      }
    });

    let exclude_org = new Set();
    $("input.filter-org").each(function() {
      if (! $(this).prop("checked")) {
        exclude_org.add($(this).data("value"));
      }
    });

    let filter_count = 0;
    anno_matches_filtered = new Array();
    anno_matches_all.forEach((elem, idx) => {
      if (!exclude_cmp.has(elem["annotation__chembl_id_lookup__chembl_id"]) &&
          !exclude_tgt.has(elem["annotation__component_sequences__accession"]) &&
          !exclude_org.has(elem["annotation__component_sequences__organism"]))
      {
        anno_matches_filtered.push(elem);
      } else {
        filter_count++;
      }
    });

    if (filter_count === 1) {
      $("#filter_count").html("1 result has been filtered out.")
    } else {
      $("#filter_count").html(filter_count + " results have been filtered out.")
    }

    console.log("exclude_cmp:", exclude_cmp);
    console.log("exclude_tgt:", exclude_tgt);
    console.log("exclude_org:", exclude_org);
    console.log("END applyFilters");
    tbl.clear();
    tbl.rows.add(anno_matches_filtered);
    tbl.draw();
    console.log("Redrew DataTables");
  }

  function dtSelectNode(node_id) {
    network.setSelection({ nodes: [node_id] });
    updateInfoPanel(node_id);
    document.getElementById("graph-row").scrollIntoView({behavior: "smooth"});
  }

  function resetNodeColors() {
    nodesDS.getIds().forEach((elem, idx) => {
      nodesDS.updateOnly({id: elem, color: ""});
    });

    nctIconColors = new Object();
    refreshNCTicons();

    /*$(".pw-table-row").each(function() {
      $(this).removeClass("pw-table-row-highlight");
    });*/
    mostRecentPathway = null;
    refreshMRPW();
  }

  function refreshNCTicons() {
    $(".nct-icon").each(function () {
      let node_id = $(this).data("nodeid");
      //let node_color = nodesDS.get(node_id)["color"];
      //if (node_color === undefined || node_color === "") {
      if (!(node_id in nctIconColors)) {
        $(this).removeClass("fa-square");
        $(this).addClass("fa-paint-brush");
        $(this).css("color", "");
      } else {
        $(this).removeClass("fa-paint-brush");
        $(this).addClass("fa-square");
        $(this).css("color", nctIconColors[node_id]);
      }
    });
  }

  function refreshMRPW() {
    $(".pw-table-row").each(function () {
      if ($(this).data("nodeid") === mostRecentPathway) {
        $(this).addClass("pw-table-row-highlight");
      } else {
        $(this).removeClass("pw-table-row-highlight");
      }
    });
  }

  // Change handler for filter input fields.
  // Should update the corresponding slider, as well as min/max boundaries accordingly.
  // Currently assumes a range-type filter. Hopefully we won't add any more...
  function filterChange(filter, field) {
    let elem = $("#filter_"+filter+"_"+field);
    elem = elem[0];
    console.log("filterChange elem:", elem);

    if (elem.validity.valid === true) {
      if (field === "low") {
        // If updating a "low" field, set the min boundary for the high field
        let high_field = $("#filter_"+filter+"_high")[0];
        high_field.min = elem.value;
        // Update the slider
        sliders[filter].slider("values", 0, elem.value);
      } else if (field === "high") {
        // If updating a "high" field, set the max boundary for the low field
        let low_field = $("#filter_"+filter+"_low")[0];
        low_field.max = elem.value;
        sliders[filter].slider("values", 1, elem.value);
      } else {
        console.error("filterChange: expected field of 'low' or 'high'");
      }
    } else {
      console.error("filterChange: ignoring invalid value");
    }
  }

  const dtColumnsBasic = [
  {% for c in cols_basic %}
    { name: '{{c}}', data: '{{c}}', title: table_info['{{c}}']['name']}{% if not forloop.last %},{% endif %}
  {% endfor %}
  ]

  const dtColumnDefs = [
  {
    "targets": [0,3],
    "render": function (d,t,r,m) { return '<a href="javascript:dtSelectNode(\''+d+'\')">'+d+'</a>'; }
  }
  ]

  const dtColumnsAll = [
  {% for c in cols %}
    {% if forloop.last %}{ data: '{{c}}' }
    {% else %}{ data: '{{c}}'},{% endif %}
  {% endfor %}
  ]

  var cmpNodes = new Map(); // cmpNodes[CHEMBLID] = cmp_data_map...
  var tgtNodes = new Map(); // tgtNodes[CHEMBLID] = tgt_data_map...

  var nameToId = new Map(); // translate compound/target name to node ID
  var idToName = new Map(); // reverse...

  // TODO: This should be moved into Django
  // TODO: Fill in min/max values in filters after move-to-Django
  // TODO: Remove nodeId. Strings work just fine as node identification
  // Document all graph nodes into cmpNodes/tgtNodes
  var nodeId = 1;
  anno_matches_all.forEach((elem, idx) => {
    // Every node on the graph needs a unique ID
    // Be sure to increment this immediately after assignment
    //let nodeId = 1;
    //nodeId = 1;

    // Gather compound nodes by ChEMBL ID, skip duplicates
    let chemblId = elem['annotation__chembl_id_lookup__chembl_id'];
    if (cmpNodes.has(chemblId) === false) {
      let cmp = new Map();
      cmp.set('id', nodeId);
      nameToId.set(chemblId, nodeId);
      idToName.set(nodeId, chemblId);
      //console.log("before:", nodeId);
      nodeId++;
      //console.log("after:", nodeId);
      // Place additional useful info below
      cmp.set('Entity Type', elem['annotation__chembl_id_lookup__entity_type']);
      cmp.set('Preferred Name', elem['annotation__molecule_dictionary__pref_name']);
      cmp.set('Mechanism of Action', elem['annotation__drug_mechanism__mechanism_of_action']);
      cmp.set('Number of Target Relations', 1);
      // Save to parent data structure
      cmpNodes.set(chemblId, cmp);
    } else {
      let rel = cmpNodes.get(chemblId).get('Number of Target Relations');
      cmpNodes.get(chemblId).set('Number of Target Relations', rel+1);
    }

    // Gather target nodes by accession ID, skip duplicates
    let accId = elem['annotation__component_sequences__accession'];
    if (tgtNodes.has(accId) === false) {
      let tgt = new Map();
      tgt.set('id', nodeId);
      nameToId.set(accId, nodeId);
      idToName.set(nodeId, accId);
      nodeId++;
      // Place additional useful info below
      tgt.set('Description', elem['annotation__component_sequences__description']);
      tgt.set('Organism', elem['annotation__component_sequences__organism']);
      tgt.set('Number of Compound Relations', 1);
      // Save to parent data structure
      tgtNodes.set(accId, tgt);
    } else {
      let rel = tgtNodes.get(accId).get('Number of Compound Relations');
      tgtNodes.get(accId).set('Number of Compound Relations', rel+1);
    }
  });

  $(document).ready(function() {
    //tbl = $('#dt').DataTable({});
    tbl = $('#dt').DataTable({
      data: anno_matches_filtered,
      pageLength: 25,
      columns: dtColumnsBasic,
      columnDefs: dtColumnDefs
    });

    let a = $("#filter_ct_low")[0].value;
    let b = $("#filter_ct_high")[0].value;
    sliders["ct"] = $("#filter_ct_slider").slider({
      range: true,
      min: 1,
      max: {{ct_max}},
      values: [a, b],
      slide: function(event, ui) {
        console.log("filter_ct_slider ui:", ui);
        $("#filter_ct_low")[0].value = ui.values[0];
        $("#filter_ct_high")[0].value = ui.values[1];
        $("#filter_ct_high")[0].min = ui.values[0];
        $("#filter_ct_low")[0].max = ui.values[1];
      }
    });

    a = $("#filter_tc_low")[0].value;
    b = $("#filter_tc_high")[0].value;
    sliders["tc"] = $("#filter_tc_slider").slider({
      range: true,
      min: 1,
      max: {{tc_max}},
      values: [a, b],
      slide: function(event, ui) {
        console.log("filter_tc_slider ui:", ui);
        $("#filter_tc_low")[0].value = ui.values[0];
        $("#filter_tc_high")[0].value = ui.values[1];
        $("#filter_tc_high")[0].min = ui.values[0];
        $("#filter_tc_low")[0].max = ui.values[1];
      }
    });

    $("#filter_test_slider").slider({
      range: true,
      min: 1,
      max: 10,
      values: [1, 10]
    });

    //$(".filter-range").on("change", function(event) {
      //console.log("filter-range this:", $(this));
      //console.log("filter-range event:", event);
    //});

    $("[data-toggle=tooltip]").tooltip();

    loadGraph();

  });

</script>
{% endblock js_content %}
